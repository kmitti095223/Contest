----------------
C++でプログラムを書いて。

Tは「100000000000000000001」のように同じ文字が連続している場合があります。
Pの長さは最大1000文字のため、1001文字以上同じ文字が連続している場合、参照する必要はありません。
Tの文字列の1001文字以上連続した部分を、1000文字までに変更してください。
Tの配列自体を書き換えて。

----------------
高速化する方法を考えました。

「1〜nPrefixLengthのループ」の部分が遅い。
この部分ではTの各文字に対してインデックスを計算している。
2種類の文字で構成されている問題の場合、nPrefixLength=20のため、
Tの各文字に対して20回ループする。

Tの連続した2文字のインデックスは似ているので差分のみを計算すればよい。
例えば、nPrefixLength=3で、baseSize＝6、Tが「ABCDEF」の場合、インデックスの計算は以下となっている。

Tの1文字目：Cの値×6×6 + Bの値×6 + Aの値
Tの2文字目：Dの値×6×6 + Cの値×6 + Bの値

なので
Tの2文字目のインデックス ＝ Tの1文字目のインデックス　/ 6 + Dの値×6×6
で計算できる。

ただしはminPLengthがnPrefixLengthより小さい場合、計算がややこしくなる。
というわけで、minPLength が nPrefixLength以上の場合のみ高速化するロジックを組み込む。

変更内容：
"""
・「1〜nPrefixLengthのループ」の部分を、minPLengthがnPrefixLength以上の場合とその他の場合で分岐して。
・minPLengthがnPrefixLength以上の場合、ひとつ前のTのインデックスを基にして、現在のインデックスを計算して。
・Tの1文字目の処理では、ひとつ前のインデックスがないため、minPLengthがnPrefixLengthより小さい方のルートを通して。
・上記以外は一切変えないで。コメントも変えないで。
"""







